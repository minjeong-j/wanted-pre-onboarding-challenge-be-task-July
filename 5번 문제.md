
### Java에서 자료구조와 관련 된 클래스가 내부적으로 어떻게 동작하는지 한 가지 사례를 정하여 작성해주세요.

#### ArrayList 선택한 이유 : ArrayList는 가장 많이 사용했던 Collection Framework로, 이번 기회에 더 자세히 알아봐야겠다 생각이 들어 선택하였습니다. 

#### ArrayList 사례
1. 생성
```java
ArrayList<String> list = new ArrayList<>();

public ArrayList() {  
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;  
}
```
ArrayList를 새로 생성합니다. 
기본 생성자 elementData 필드에 DEFAULTCAPACITY_EMPTY_ELEMENTDATA를 할당해줍니다. 


```java
transient Object[] elementData;

private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};
```
elementData는 ArrayList 요소가 저장되는 배열 버퍼입니다. 
버퍼(buffer) : 데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 임시 메모리 영역 - 입출력속도 향상을 위해 사용

transient : 직렬화(Serialize) 대상에서 제외되지만, 직렬화가 불가능하다는 점은 아니라 ArrayList는 이에 따라 다른 직렬화 로직을 따르게 됩니다. 
DEFAULTCAPACITY_EMPTY_ELEMENTDATA로 비어있는 Object 배열을 생성하는데 이 필드가 ArrayList의 역할을 할 필드로, 
자료를 추가하고 삭제하면 위 배열에 추가되고 삭제됩니다. 

2. 추가 
ArrayList에 요소를 추가합니다. 

```java
list.add("hello")
list.add("Java")
```

추가한 데이터들을 확인해보기 위해 add Method를 확인해보겠습니다. 

```java
public boolean add(E e) { //E : String, e : "hello"
	modCount++;
	add(e, elementData, size);		//add("hello", elementData, 0)
	return true;
}
```
modCount를 증가시키고 add(e, elementData, size) 함수를 실행하고 
마지막으로 true를 return합니다. 

modCount : ArrayList가 상속한 AbstractList 클래스에 있는 필드로 ArrayList 자료구조에 얼마나 수정이 되었는지에 대한 횟수를 체크하는 필드. 



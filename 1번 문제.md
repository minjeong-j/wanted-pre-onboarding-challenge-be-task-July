#### 교착상태(Deadlock)을 DB에서 사용할 수 있는 가장 단순한 방법
1. 트랜잭션을 짧게 유지하고 트랜잭션 중 사용자 입력 방지를 한다. 
2. 하나의 트랜잭션을 완료하면 COMMIT 한다.

  
```
   START TRANSACTION
   update item set itemCode = '1234' where itemId = 2; 
   COMMIT;
```

#### 자바 기반 웹프로그램 기준 데이터베이스의 lock을 이용하는 방법 -> 해당 레코드의 트랜잭션 동안 lock을 점유하는 것
1. 쿼리를 통해 락 점유 : For update를 통해 트랜잭션 수행동안 락을 획득해 멀티 스레드 환경에서도 리소스를 점유함
   
```java
<select id="selectStockOfProduct" resultType="int">
	SELECT PRODUCT_STOCK
	FROM PRODUCT
	WHERE PRODUCT_NAME=#{productName}
	FOR UPDATE
</select>
```

3. 서비스 레이어에 트랜잭션을 건다 
: DB와 관련된 트랜잭션이 필요한 서비스 클래스 혹은 메소드에 @Transactional 어노테이션을 달아준다. 
: @Transactional이 붙은 메소드는 메소드가 포함하고 있는 작업 중에 하나라도 실패할 경우 전체 작업을 취소한다.  

```java
@Transactional 
public String getKakaoPayUrl(OrderDTO orderDTO, HttpServletRequest request) throws RunOutOfStockException {
		
	/*재고 확인*/
	int productStock = productMapper.selectStockOfProduct(OrderDTO orderDTO.getItemName());
	if(OrderDTO.getQuantity() > productStock) {
		throw new RunOutOfS
	}
	
	/*재고 차감*/
 /* 
 같은 메소드 내 update 쿼리 
 => 예외가 발생하면 전부 롤백이 되어야 한다. 
 =>트랜잭션의 Atomicity : 원자성. 트랜잭션과 관련된 일은 모두 실행되던지 모두 실행되지 않도록 하던지를 보장하는 특성
 */
	updateStock(productStock - orderDTO.getQuantity(), orderDTO.getItemName(), "product_name");
}
```
